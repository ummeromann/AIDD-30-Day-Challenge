# ğŸ“Part A â€” Theory

# 1. Nine Pillars Understanding

# Why is using AI Development Agents (like Gemini CLI) for repetitive setup tasks better for your growth as a system architect?

*Using AI Development Agents like Gemini CLI for repetitive setup tasks is better
for your growth as a system architect because it frees you from manual, repetitive
work and lets you focus on higher-level thinking. Instead of spending time on boilerplate
code, environment setup, or configuration, you can spend your energy on designing the 
system, planning architecture, and solving complex problems.

It also trains you to think in terms of intent you guide the AI on what you want to achieve
rather than how to do every step. Over time, this shift from execution to orchestration helps
you grow from being just a coder to a true system architect, capable of planning, managing,
and optimizing entire systems.

In short: AI handles the repetitive tasks, and you handle the big-picture decisions that
actually matter.

# Explain how the Nine Pillars of AIDD help a developer grow into an M-Shaped Developer.

*The Nine Pillars of AIDD help a developer grow into an M-Shaped Developer by giving them a broad and deep set of skills across AI-driven development.

Instead of focusing only on coding or one narrow area, the Nine Pillars cover everything from prompting AI, designing systems, evaluating outputs, deploying solutions, to continuously improving processes. Practicing these pillars pushes a developer to develop multiple strengths both technical depth in AI and system design, and cross functional skills like orchestration, automation, and strategy.

This combination is what makes someone M-Shaped: they are not just deep in one skill (I-shaped) or shallow in many (T-shaped), but deep in several areas and able to connect them. The Nine Pillars guide a developer to think, act, and create like a well-rounded AI-driven system architect, capable of designing, building, and optimizing complex AI solutions.

# 2. Vibe Coding vs Specification-Driven Development

# Why does Vibe Coding usually create problems after one week?

*Vibe Coding usually causes problems after a week because itâ€™s all about quick experimentation without much structure.
In the beginning, everything feels fast and fun youâ€™re trying ideas and writing code quickly. But since thereâ€™s no proper plan,
testing, or organization, the code soon becomes messy.

After a few days, small mistakes start piling up, features break, and it becomes hard to manage or add new things.
Basically, what felt fast at first turns into a headache, because the project has built up technical debt.

In short: Vibe Coding is fine for experimenting, but if you keep it going without discipline, it quickly creates chaos.

# How would Specification-Driven Development prevent those problems?

*Specification-Driven Development (SDD) prevents those problems by bringing structure and clarity to the development process.
Instead of coding based on vibes or quick ideas, you start with a clear specification: what the system should do, how it should behave,
and what success looks like.

With SDD:
Every feature is planned before coding, so thereâ€™s less guesswork.

Code is organized and maintainable, making it easier to add new features
.
Testing and validation are built into the workflow, so bugs are caught early.

The project stays aligned with the bigger goals, preventing technical debt from piling up.

In simple terms: SDD turns fast, messy experiments into predictable, reliable, and scalable development.
You still move forward efficiently, but now with discipline and control, so your code doesnâ€™t collapse after a week.

# 3. Architecture Thinking

# How does architecture-first thinking change the role of a developer in AIDD?

*Architecture-first thinking shifts a developer from just coding to designing and orchestrating systems.
They focus on structure, workflows, and AI automation, guiding AI to handle repetitive tasks.
This lets developers add strategic value, ensure maintainable solutions, and focus on innovation over manual work.

# Explain why developers must think in layers and systems instead of raw code.

*Developers must think in layers and systems because software is more than code itâ€™s interconnected.
This approach organizes complexity, enables reuse, ensures scalability, and keeps the system maintainable, unlike focusing on raw code alone.

# ğŸ“ Part B â€” Practical Task
# Task:
# Using any AI CLI tool, generate a 1-paragraph specification for an email validation function.

"Generate a 1-paragraph specification for an email validation function. 
The function must:
1. Ensure the input contains the '@' symbol.
2. Verify that the domain is valid (e.g., '.com', '.org').
3. Return clear error messages if the email is invalid, such as 'Missing @ symbol' or 'Invalid domain name'.
4. Handle edge cases like empty strings, extra spaces, or malformed input.
Write the specification in a clear, concise, and professional style."

> Output:
The email validation function should check whether a given input is a valid email address. It must ensure that the input contains the "@" symbol and that the part after "@" includes a valid domain, such as ".com" or ".org". The function should return true if the email is valid. If the email is invalid, it must provide clear, specific error messages, such as "Missing '@' symbol" or "Invalid domain name," so the user understands exactly what needs to be corrected. The function should also handle edge cases like empty strings, extra spaces, or malformed input.

# ğŸ“Part C â€” Multiple Choice Questions

Here are the correct answers:

1. B

2. B

3. B

4. B

5. C
